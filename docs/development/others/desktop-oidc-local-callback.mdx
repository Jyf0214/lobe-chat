# Desktop OIDC Local Callback Plan

## Summary

Switch the desktop OIDC flow from polling-only to a dual-channel flow that prefers a local callback server and falls back to polling. Bind the local notify port to the OIDC state on the server so the callback route can safely redirect to localhost without taking a port from user input.

## Goals

- Reduce latency by receiving the callback locally.
- Keep polling as a fallback if the local channel fails.
- Avoid open-redirect risks by binding notify ports to state on the server.
- Preserve existing PKCE and state validation.

## Flow

Current flow:

```
Browser -> /oidc/callback/desktop -> DB(handoff) -> Electron polls /oidc/handoff -> Token exchange
```

New flow:

```
Electron starts local server on 127.0.0.1:34210..34219
Electron POST /oidc/handoff (id=state, client=desktop, notifyPort)
Browser -> /oidc/auth (state)
Browser -> /oidc/callback/desktop
  -> DB(handoff) { code/state or error } + notifyPort (if registered)
  -> if notifyPort: redirect to http://127.0.0.1:{port}/notify
Electron waits for local callback; polling continues as fallback
First successful result wins, then exchange token
```

## Data model

Reuse `oauth_handoffs.payload` for two phases:

- Pending: `{ notifyPort: number }`
- Complete:
  - Success: `{ code: string; state: string; notifyPort?: number }`
  - Error: `{ error: string; error_description?: string; state: string; notifyPort?: number }`

`fetchAndConsume` must only return a record when `code` or `error` is present, otherwise keep it for later.

## API changes

Add a registration endpoint to bind state -> notifyPort:

- `POST /oidc/handoff`
  - Body: `{ id: string; client: 'desktop'; notifyPort: number }`
  - Validates port in the allowed range.
  - Upserts payload to include `notifyPort`.

`GET /oidc/handoff` stays the polling endpoint.

## Server changes

- `/oidc/callback/desktop`:
  - Accept `code/state` or `error/error_description/state`.
  - Merge payload with any existing `notifyPort`.
  - Redirect to local `http://127.0.0.1:{notifyPort}/notify` only if the port is registered for this state.
  - Otherwise, redirect to the normal success/error pages.

## Desktop changes

- New `OIDCCallbackServerManager` to:
  - Bind `127.0.0.1` and listen on `34210..34219`.
  - Resolve a promise on `/notify?code=...&state=...` or `/notify?error=...&state=...`.
  - Return a success or error HTML page to the browser.
  - Time out after 5 minutes and close the server.

- `AuthCtr`:
  - Start local server and register `notifyPort` before opening the browser.
  - Start polling as fallback.
  - If local callback returns `error`, stop polling and surface failure.
  - If local callback times out or is invalid, keep polling.
  - Only the first successful result triggers token exchange.

## Security

- Redirect only to a port stored on the server for this state.
- Only listen on `127.0.0.1`.
- Keep PKCE + state validation unchanged.
- Validate the notify port is in the configured range.

## Test plan

- `OAuthHandoffModel`:
  - Ensure `fetchAndConsume` ignores pending records with only `notifyPort`.
  - Ensure upsert/merge preserves `notifyPort`.
- Desktop:
  - Mock local callback manager and verify polling still works as fallback.
  - Verify local callback error stops polling and reports failure.

